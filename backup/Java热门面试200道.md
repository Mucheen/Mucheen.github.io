# 1、Java中HashMap的原理
**简洁回答**：哈希函数映射到数组桶；哈希冲突通过链表或红黑树处理；扩容机制根据负载因子和容量动态调整。
HashMap是基于哈希表的数据结构，用于存储**键值对**（key-value）。其核心是将键的哈希值映射到数组索引位置；通过**数组+链表**（在Java8及之后是**数组+链表+红黑树**）来处理哈希冲突；支持O(1)的平均时间复杂度来执行 put、get和remove操作，但在发生扩容时会有性能开销。默认的负载因子是0.75，容量初始为16，并在超过阈值时扩容

# 2、Java中ConcurrentHashMap 1.7和1.8之间有哪些区别？
**JDK 1.7** ConcurrentHashMap采用的是分段锁，即每个Segment是独立的，可以并发访问不同的Segment，默认是16个Segment，所以最多有16个线程可以并发执行。而JDK 1,8移除了Segment，锁的粒度变得更加细化，锁只在链表或红黑树的节点级别上进行。通过CAS进行插入操作，只有在更新链表或红黑树时才使用synchronized，并且只锁住链表或树的头节点，进一步减少了锁的竞争，并发度大大增加。

# 3、为什么JDK 1.8对HashMap进行了红黑树的改动？
**简洁回答**：红黑树时一种平衡二叉树，插入、删除和查找操作时的时间复杂度为O(logn)，在元素多的情况下远优于链表
在JDK1,.8之前，HashMap使用链表来解决哈希冲突。当哈希冲突较多时，链表中的元素增多，查找、插入和删除的时间复杂度从O(1)退化为O(n)。因此在JDK1.8引入了红黑树，将链表长度超过一定阈值（默认为8）时的链表转换为红黑树，避免性能急剧下降。当链表降到6以下时，红黑树会重新退化为链表，保持简单高效。

# 4、JDK1.8对HashMap除了红黑树还进行了哪些改动？
（1）改进了哈希函数的计算：JDK1.8中优化了哈希函数，使得哈希值的分布更加均匀，减少了哈希冲突的发生。通过在生成哈希值时使用“扰动函数”，确保哈希值的高低位都能参与到桶的选择中
（2）扩容机制优化：JDK1.8改进了扩容时的元素迁移机制。在扩容过程中不再对每个元素重新计算哈希值，而是根据原数组长度的高位来判断元素是留在原位置。这一改动减少了不必要的计算，提高了扩容效率。

# 5、Java中有哪些集合类？请简单介绍
Java中的集合类主要分为两大类：Collection接口和Map接口。前者存储对象的集合类，后者存储的是键值对(key-value)
## Collection
1）List系列集合：添加的元素是有序、可重复、有索引
          ArrayList、LinkedList：有序、可重复、有索引。
2）Set系列集合：无序、不重复、无索引
          HashSet：无序、不重复、无索引
          LinkedHashSet：有序、不重复、无索引
          TreeSet：按照大小默认升序排序、不重复、无索引
## Map
HashMap：元素按照键是无序、不重复、无索引。值不做要求
LinkedHashMap：元素按照键是有序，不重复，无索引。值不做要求
TreeMap :元素按照键是排序，不重复，无索引的。值不做要求