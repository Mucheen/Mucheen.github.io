# 1、Java中HashMap的原理
**简洁回答**：哈希函数映射到数组桶；哈希冲突通过链表或红黑树处理；扩容机制根据负载因子和容量动态调整。
HashMap是基于哈希表的数据结构，用于存储**键值对**（key-value）。其核心是将键的哈希值映射到数组索引位置；通过**数组+链表**（在Java8及之后是**数组+链表+红黑树**）来处理哈希冲突；支持O(1)的平均时间复杂度来执行 put、get和remove操作，但在发生扩容时会有性能开销。默认的负载因子是0.75，容量初始为16，并在超过阈值时扩容

# 2、Java中ConcurrentHashMap 1.7和1.8之间有哪些区别？
**JDK 1.7** ConcurrentHashMap采用的是分段锁，即每个Segment是独立的，可以并发访问不同的Segment，默认是16个Segment，所以最多有16个线程可以并发执行。而JDK 1,8移除了Segment，锁的粒度变得更加细化，锁只在链表或红黑树的节点级别上进行。通过CAS进行插入操作，只有在更新链表或红黑树时才使用synchronized，并且只锁住链表或树的头节点，进一步减少了锁的竞争，并发度大大增加。

# 3、为什么JDK 1.8对HashMap进行了红黑树的改动？
在JDK1,.8之前，HashMap使用链表来解决哈希冲突。当哈希冲突较多时，链表中的元素增多，查找、插入和删除的时间复杂度从O(1)退化为O(n)。